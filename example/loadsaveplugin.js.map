{"version":3,"sources":["loadsaveplugin.litcoffee"],"names":["LoadSave","bind","fn","me","apply","arguments","editor1","control","this","editor","setAppName","prototype","appName","setFileSystem","setFilepath","FileSystem","pathSeparator","setTimeout","_this","clear","saveMetaData","loadMetaData","on","event","setDocumentDirty","name","data","buttonData","key","icon","shortcut","onclick","tooltip","addButton","addMenuItem","text","context","tryToClear","tryToSave","handleOpen","manageFiles","instances","push","newname","i","instance","len","ref","results","length","recomputePageTitle","document","title","filename","documentDirty","setting","setFilename","newpath","filepath","mustAlsoUpdateFileSystem","fileSystem","setContent","undoManager","windowManager","open","buttons","success","close","focus","save","objectToSave","tmp","cd","getContent","write","callback","refreshDialog","result","saveWouldOverwrite","button","dialog","getElementsByClassName","getElementsByTagName","textContent","removeAttribute","parentNode","style","backgroundImage","backgroundColor","setAttribute","saveFileNameChangedHandler","changedFolderHandler","newfolder","type","buttonClickedHandler","slice","call","confirm","tellDialog","url","width","height","subtype","fsName","mode","load","content","metadata","read","tryToOpen","p","f","selectedFileHandler","args","frame","frames","getAttribute","contentWindow","postMessage","installOpenHandler","handler","replaceInternalHandler","installSaveHandler","installManageFilesHandler","internalName","newHandler","base","handlerBackups","tinymce","PluginManager","add","window","onmessage","handlerName","hasOwnProperty"],"mappings":"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","file":"loadsaveplugin.js","sourcesContent":["\n# Load/Save Plugin for [TinyMCE](http://www.tinymce.com)\n\nThis plugin will leverage [jsfs](https://github.com/nathancarter/jsfs) to\nadd load and save functionality to a TinyMCE instance.  It assumes that both\nTinyMCE and jsfs have been loaded into the global namespace, so that it can\naccess both.\n\n# `LoadSave` class\n\nWe begin by defining a class that will contain all the information needed\nregarding loading and saving a document.  An instance of this class will be\nstored as a member in the TinyMCE editor object.  The presence of that\nmember indicates that the plugin has been installed, and provides access to\nthe full range of functionality that the plugin grants to that editor.\n\n    class LoadSave\n\n## Class variables\n\nAs a class variable, we store the name of the app.  We allow changing this\nby a global function defined at the end of this file.  Be default, there is\nno app name.  If one is provided, it will be used when filling in the title\nof the page, upon changes to the filename and/or document dirty state.\n\n        appName: null\n\nIt comes with a setter, so that if the app name changes, all instances will\nautomatically change their app names as well.\n\n        @setAppName: ( newname = null ) ->\n            LoadSave::appName = newname\n            instance.setAppName newname for instance in LoadSave::instances\n\nWe must therefore track all instances in a class variable.\n\n        instances: [ ]\n\n## Constructor\n\nA newly-constructed document defaults to being clean, having no filename,\nand using the app name as the filesystem name.  These attributes can be\nchanged with the setters defined in the following section.\n\n        constructor: ( @editor ) ->\n            @setAppName LoadSave::appName\n            @setFileSystem @appName\n            @setFilepath FileSystem::pathSeparator # root\n            setTimeout ( => @clear() ), 0\n\nThe following handlers exist for wrapping metadata around a document before\nsaving, or unwrapping after loading.  They default to null, but can be\noverridden by a client by direct assignment of functions to these members.\n\nThe `saveMetaData` function should take no inputs, and yield as output a\nsingle object encoding all the metadata as key-value pairs in the object.\nIt will be saved together with the document content.\n\nThe `loadMetaData` function should take as input one argument, an object\nthat was previously created by the a call to `saveMetaData`, and repopulate\nthe UI and memory with the relevant portions of that document metadata.  It\nis called immediately after a document is loaded.  It is also called when a\nnew document is created, with an empty object to initialize the metadata.\n\n            @saveMetaData = @loadMetaData = null\n\nWhenever the contents of the document changes, we mark the document dirty in\nthis object, which therefore adds the \\* marker to the page title.\n\n            @editor.on 'change', ( event ) => @setDocumentDirty yes\n\nNow install into the editor controls that run methods in this object.  The\n`control` method does something seemingly inefficient to duplicate the input\ndata object to pass to `addButton`, but this turns out to be necessary, or\nthe menu items look like buttons.  (I believe TinyMCE manipulates the object\nupon receipt.)\n\n            control = ( name, data ) =>\n                buttonData =\n                    icon : data.icon\n                    shortcut : data.shortcut\n                    onclick : data.onclick\n                    tooltip : data.tooltip\n                key = if data.icon? then 'icon' else 'text'\n                buttonData[key] = data[key]\n                @editor.addButton name, buttonData\n                @editor.addMenuItem name, data\n            control 'newfile',\n                text : 'New'\n                icon : 'newdocument'\n                context : 'file'\n                shortcut : 'meta+alt+N'\n                tooltip : 'New file'\n                onclick : => @tryToClear()\n            control 'savefile',\n                text : 'Save'\n                icon : 'save'\n                context : 'file'\n                shortcut : 'meta+S'\n                tooltip : 'Save file'\n                onclick : => @tryToSave()\n            @editor.addMenuItem 'saveas',\n                text : 'Save as...'\n                context : 'file'\n                shortcut : 'meta+shift+S'\n                onclick : => @tryToSave null, ''\n            control 'openfile',\n                text : 'Open...'\n                icon : 'browse'\n                context : 'file'\n                shortcut : 'meta+O'\n                tooltip : 'Open file...'\n                onclick : => @handleOpen()\n            @editor.addMenuItem 'managefiles',\n                text : 'Manage files...'\n                context : 'file'\n                onclick : => @manageFiles()\n\nLastly, keep track of this instance in the class member for that purpose.\n\n            LoadSave::instances.push this\n\n## Setters\n\nWe then provide setters for the `@documentDirty`, `@filename`, and\n`@appName` members, because changes to those members trigger the\nrecomputation of the page title.  The page title will be of the form \"app\nname: document title \\*\", where the \\* is only present if the document is\ndirty, and the app name (with colon) are omitted if none has been specified\nin code.\n\n        recomputePageTitle: =>\n            document.title = \"#{if @appName then @appName+': ' else ''}\n                              #{@filename or '(untitled)'}\n                              #{if @documentDirty then '*' else ''}\"\n        setDocumentDirty: ( setting = yes ) =>\n            @documentDirty = setting\n            @recomputePageTitle()\n        setFilename: ( newname = null ) =>\n            @filename = newname\n            @recomputePageTitle()\n        setFilepath: ( newpath = null ) => @filepath = newpath\n        setAppName: ( newname = null ) =>\n            mustAlsoUpdateFileSystem = @appName is @fileSystem\n            @appName = newname\n            if mustAlsoUpdateFileSystem then @fileSystem = @appName\n            @recomputePageTitle()\n        setFileSystem: ( newname = @appName ) => @fileSystem = newname\n\n## New documents\n\nTo clear the contents of the editor, use this method in its `LoadSave`\nmember.  It handles notifying this instance that the document is then clean.\nIt does *not* check to see if the document needs to be saved first; it just\noutright clears the editor.  It also clears the filename, so that if you\ncreate a new document and then save, it does not save over your last\ndocument.\n\n        clear: =>\n            @editor.setContent ''\n            @editor.undoManager.clear()\n            @setDocumentDirty no\n            @setFilename null\n            @loadMetaData? { }\n\nUnlike the previous, this function *does* first check to see if the contents\nof the editor need to be saved.  If they do, and they aren't saved (or if\nthe user cancels), then the clear is aborted.  Otherwise, clear is run.\n\n        tryToClear: =>\n            if not @documentDirty\n                @clear()\n                @editor.focus()\n                return\n            @editor.windowManager.open {\n                title : 'Save first?'\n                buttons : [\n                    text : 'Save'\n                    onclick : =>\n                        @tryToSave ( success ) => if success then @clear()\n                        @editor.windowManager.close()\n                ,\n                    text : 'Discard'\n                    onclick : =>\n                        @clear()\n                        @editor.windowManager.close()\n                ,\n                    text : 'Cancel'\n                    onclick : => @editor.windowManager.close()\n                ]\n            }\n\n## Saving documents\n\nTo save the current document under the filename in the `@filename` member,\ncall the following function.  It returns a boolean indicating success or\nfailure.  If there is no filename in the `@filename` member, failure is\nreturned and no action taken.  If the save succeeds, mark the document\nclean.\n\n        save: =>\n            if @filename is null then return\n            tmp = new FileSystem @fileSystem\n            tmp.cd @filepath\n            objectToSave = [ @editor.getContent(), @saveMetaData?() ]\n            if tmp.write @filename, objectToSave, yes # use compression\n                @setDocumentDirty no\n\nThis function tries to save the current document.  When the save has been\ncompleted or canceled, the callback will be called, with one of the\nfollowing parameters:  `false` means the save was canceled, `true` means it\nsucceeded, and any string means there was an error.  If the save succeeded,\nthe internal `@filename` field of this object may have been updated.\n\nTo force a save into a file other than the current `@filename`, pass the\nother filename as the optional second parameter.  To force \"save as\"\nbehavior when there is a current `@filename`, pass null as the optional\nsecond parameter.\n\n        tryToSave: ( callback, filename = @filename ) =>\n\nIf there is a filename for the current document already in this object's\n`@filename` member, then a save is done directly to that filename.  If there\nis no filename, then a save dialog is shown.\n\n            if filename\n                @setFilename filename\n                result = @save() # save happens even if no callback\n                @editor.focus()\n                return callback? result\n\nThere is not a readily available filename, so we must pop up a \"Save as\"\ndialog.  First we create a routine for updating the dialog we're about to\nshow with an enabled/disabled Save button, based on whether there is a file\nselected.\n\n            refreshDialog = ->\n                dialog = document.getElementsByClassName( 'mce-window' )[0]\n                if not dialog then return\n                for button in dialog.getElementsByTagName 'button'\n                    if button.textContent is 'Save'\n                        if filename\n                            button.removeAttribute 'disabled'\n                            button.parentNode.style.backgroundImage = null\n                            button.parentNode.style.backgroundColor = null\n                        else\n                            button.setAttribute 'disabled', yes\n                            button.parentNode.style.backgroundImage = 'none'\n                            button.parentNode.style.backgroundColor = '#ccc'\n                        break\n\nNow we install a handler for when a file is selected, save that filename for\npossible later use, and refresh the dialog.\n\n            filename = null\n            @saveFileNameChangedHandler = ( newname ) ->\n                filename = newname\n                refreshDialog()\n\nDo the same thing for when the folder changes, but there's no need to\nrefresh the dialog in this case.\n\n            filepath = null\n            @changedFolderHandler = ( newfolder ) -> filepath = newfolder\n\nWe will also need to know whether the `save` function will overwrite an\nexisting file, so that we can verify that the user actually wants to do so\nbefore we save.  The following function performs that check.\n\n            saveWouldOverwrite = ( filepath, filename ) =>\n                tmp = new FileSystem @fileSystem\n                tmp.cd filepath\n                null isnt tmp.type filename\n\nCreate a handler to receive the button clicks.  We do this here so that if\nthe dialog clicks a button programmatically, which then passes to us a\nmessage that the button was clicked, we will still hear it through this\nhandler, because the `window.onmessage` handler installed at the end of this\nfile will call this function.\n\n            @buttonClickedHandler = ( name, args... ) =>\n                if name is 'Save'\n\nIf the file chosen already exists, ask the user if they're sure they want to\noverwrite it.  If they say no, then we go back to the save dialog.  However,\nthe dialog, by default, resets itself to \"manage files\" mode whenever a\nbutton is clicked.  So we put it back in \"save file\" mode before exiting.\n\n                    if saveWouldOverwrite filepath, filename\n                        if not confirm \"Are you sure you want to overwrite\n                          the file #{filename}?\"\n                            @tellDialog 'setFileBrowserMode', 'save file'\n                            return\n\nNow that we're sure the user wants to save, we store the path and filename\nfor use in later saves, and perform the save, closing the dialog.\n\n                    @setFilepath filepath\n                    @setFilename filename\n                    @editor.windowManager.close()\n                    result = @save() # save happens even if no callback\n                    callback? result\n                else if name is 'Cancel'\n                    @editor.windowManager.close()\n                    callback? no\n\nNow we are sufficiently ready to pop up the dialog.  We use one made from\n[filedialog.html](filedialog.html), which was taken from\n[the jsfs repository](https://github.com/nathancarter/jsfs) and modified to\nsuit the needs of this application.\n\n            @editor.windowManager.open {\n                title : 'Save file...'\n                url : 'filedialog.html'\n                width : 600\n                height : 400\n                buttons : [\n                    text : 'Save'\n                    subtype : 'primary'\n                    onclick : => @buttonClickedHandler 'Save'\n                ,\n                    text : 'Cancel'\n                    onclick : => @buttonClickedHandler 'Cancel'\n                ]\n            }, {\n                fsName : @fileSystem\n                mode : 'save file'\n            }\n\n## Loading documents\n\nThe following function loads into the editor the contents of the file.  It\nmust be a file containing a string of HTML, because that content will be\ndirectly used as the content of the editor.  The current path and filename\nof this plugin are set to be the parameters passed here.\n\n        load: ( filepath, filename ) =>\n            if filename is null then return\n            if filepath is null then filepath = '.'\n            tmp = new FileSystem @fileSystem\n            tmp.cd filepath\n            [ content, metadata ] = tmp.read filename\n            @editor.setContent content\n            @editor.undoManager.clear()\n            @editor.focus()\n            @setFilepath filepath\n            @setFilename filename\n            @setDocumentDirty no\n            @loadMetaData? metadata ? { }\n\nThe following function pops up a dialog to the user, allowing them to choose\na filename to open.  If they choose a file, it (with the current directory)\nis passed to the given callback function.  If they do not choose a file, but\ncancel the dialog instead, then null is passed to that callback to indicate\nthe cancellation. It makes the most sense to leave the callback function the\ndefault, `@load`.\n\n        tryToOpen: ( callback = ( p, f ) => @load p, f ) =>\n\nFirst we create a routine for updating the dialog we're about to show with\nan enabled/disabled Save button, based on whether there is a file selected.\n\n            refreshDialog = =>\n                dialog = document.getElementsByClassName( 'mce-window' )[0]\n                if not dialog then return\n                for button in dialog.getElementsByTagName 'button'\n                    if button.textContent is 'Open'\n                        if filename\n                            button.removeAttribute 'disabled'\n                            button.parentNode.style.backgroundImage = null\n                            button.parentNode.style.backgroundColor = null\n                        else\n                            button.setAttribute 'disabled', yes\n                            button.parentNode.style.backgroundImage = 'none'\n                            button.parentNode.style.backgroundColor = '#ccc'\n                        break\n\nNow we install a handler for when a file is selected, which saves that\nfilename for possible later use, and refreshes the dialog.\n\n            filename = null\n            @selectedFileHandler = ( newname ) ->\n                filename = newname\n                refreshDialog()\n\nDo the same thing for when the folder changes, but there's no need to\nrefresh the dialog in this case.\n\n            filepath = null\n            @changedFolderHandler = ( newfolder ) -> filepath = newfolder\n\nCreate a handler to receive the button clicks.  We do this here so that if\nthe dialog clicks a button programmatically, which then passes to us a\nmessage that the button was clicked, we will still hear it through this\nhandler, because the `window.onmessage` handler installed at the end of this\nfile will call this function.\n\n            @buttonClickedHandler = ( name, args... ) =>\n                if name is 'Open'\n                    @editor.windowManager.close()\n                    callback? filepath, filename\n                else if name is 'Cancel'\n                    @editor.windowManager.close()\n                    callback? null, null\n\nNow we are sufficiently ready to pop up the dialog.  We use one made from\n[filedialog.html](filedialog.html), which was copied from\n[the jsfs repository](https://github.com/nathancarter/jsfs) and modified to\nsuit the needs of this application.\n\n            @editor.windowManager.open {\n                title : 'Open file...'\n                url : 'filedialog.html'\n                width : 600\n                height : 400\n                buttons : [\n                    text : 'Open'\n                    subtype : 'primary'\n                    onclick : => @buttonClickedHandler 'Open'\n                ,\n                    text : 'Cancel'\n                    onclick : => @buttonClickedHandler 'Cancel'\n                ]\n            }, {\n                fsName : @fileSystem\n                mode : 'open file'\n            }\n            refreshDialog()\n\nThe following handler for the \"open\" controls checks with the user to see if\nthey wish to save their current document first, if and only if that document\nis dirty.  The user may save, or cancel, or discard the document.\n\nBy default, the function called to open the document is `@tryToOpen`, but if\nthe caller provides a different function, it can be used instead.  For\ninstance, if this function is called before showing the open dialog for an\nonline file-sharing service, that function could be used as the callback.\n\n        handleOpen: ( callback = => @tryToOpen() ) =>\n\nFirst, if the document does not need to be saved, just do a regular \"open.\"\n\n            if not @documentDirty then return callback()\n\nNow, we know that the document needs to be saved.  So prompt the user with a\ndialog box asking what they wish to do.\n\n            @editor.windowManager.open {\n                title : 'Save first?'\n                buttons : [\n                    text : 'Save'\n                    onclick : =>\n                        @editor.windowManager.close()\n                        @tryToSave ( success ) => callback() if success\n                ,\n                    text : 'Discard'\n                    onclick : =>\n                        @editor.windowManager.close()\n                        callback()\n                ,\n                    text : 'Cancel'\n                    onclick : => @editor.windowManager.close()\n                ]\n            }\n\n## Communcating with dialogs\n\nWhen a dialog is open, it is in an `<iframe>` within the main page, which\nmeans that it can only communicate with the script environment of the main\npage through message-passing.  This function finds the `<iframe>` containing\nthe file dialog and (if there was one) sends it the message given as the\nargument list.\n\n        tellDialog: ( args... ) ->\n            frames = document.getElementsByTagName 'iframe'\n            for frame in frames\n                if 'filedialog.html' is frame.getAttribute 'src'\n                    return frame.contentWindow.postMessage args, '*'\n\n## Managing files\n\nThe final menu item is one that shows a dialog for managing files in the\nfilesystem.  On desktop apps, no such feature is necessary, because every\noperating system comes with a file manager of its own.  In web apps, where\nwe have a virtual filesystem, we must provide a file manager to access it\nand move, rename, and delete files, create folders, etc.\n\n        manageFiles: =>\n            @editor.windowManager.open {\n                title : 'Manage files'\n                url : 'filedialog.html'\n                width : 700\n                height : 500\n                buttons : [\n                    text : 'New folder'\n                    onclick : => @tellDialog 'buttonClicked', 'New folder'\n                ,\n                    text : 'Done'\n                    onclick : => @editor.windowManager.close()\n                ]\n            }, {\n                fsName : @fileSystem\n                mode : 'manage files'\n            }\n\n## Changing UI handlers\n\nThis plugin is in charge of presenting the UI for loading and saving\ndocuments, and providing default handlers for that UI that use the browser's\nLocal Storage.  But there may be other ways to load and save files, such as\nupload/download, integration with an online storage provider (Dropbox,\nGoogle Drive, etc.).  For that reason, we provide the following functions.\n\nThe first allows you to install your own handler in place of the built-in\n`tryToOpen` handler.  It accepts no arguments, and should present the user\nwith a UI for choosing a file to open, from whatever source.  If called with\nno arguments, this function installs the original handler again.  (For the\nimplementation of `replaceInternalHandler`, see further below.)\n\n        installOpenHandler: ( handler ) ->\n            @replaceInternalHandler 'tryToOpen', handler\n\nThe second allows you to install your own handler in place of the built-in\n`tryToSave` handler.  It accepts two arguments, a callback and filename,\nwhich should behave as documented in the `tryToSave` function, above.  It\nshould either save to the file specified (if one was specified), or present\nthe user with a UI for choosing where to save (if none was specified) before\nobeying the request to save.  If called with no arguments, this function\ninstalls the original handler again.\n\n        installSaveHandler: ( handler ) ->\n            @replaceInternalHandler 'tryToSave', handler\n\nThe third allows you to install your own handler in place of the built-in\n`manageFiles` handler.  It accepts no arguments, and should show the user a\nUI for browsing the files in the data store in question, if possible.  If\nnot, respond to the user's request in some way (e.g., a dialog stating that\nit is not possible, and why.)\n\n        installManageFilesHandler: ( handler ) ->\n            @replaceInternalHandler 'manageFiles', handler\n\nThe following utility function was used to implement the three functions\nabove.\n\n        replaceInternalHandler: ( internalName, newHandler ) ->\n            if newHandler?\n                ( @handlerBackups ?= { } )[internalName] ?= @[internalName]\n                @[internalName] = newHandler\n            else if @handlerBackups?[internalName]?\n                @[internalName] = @handlerBackups[internalName]\n\n# Global stuff\n\n## Installing the plugin\n\nThe plugin, when initialized on an editor, places an instance of the\n`LoadSave` class inside the editor, and points the class at that editor.\n\n    tinymce.PluginManager.add 'loadsave', ( editor, url ) ->\n        editor.LoadSave = new LoadSave editor\n\n## Event handler\n\nWhen a file dialog sends a message to the page, we look through the existing\ninstances of the `LoadSave` class for whichever one wants to handle that\nmessage.  Whichever one has a handler ready, we call that handler.\n\n    window.onmessage = ( event ) ->\n        handlerName = \"#{event.data[0]}Handler\"\n        for instance in LoadSave::instances\n            if instance.hasOwnProperty handlerName\n                return instance[handlerName].apply null, event.data[1..]\n\n## Global functions\n\nFinally, the global function that changes the app name.\n\n    window.setAppName = ( newname = null ) -> LoadSave::appName = newname\n"]}